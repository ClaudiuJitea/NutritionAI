<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Tetris</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            background-color: #f0f0f0;
            margin: 0;
            padding: 20px;
        }
        #game-container {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
        }
        #game-board {
            width: 300px;
            height: 600px;
            border: 2px solid #333;
            background-color: #111;
            position: relative;
        }
        .block {
            position: absolute;
            width: 30px;
            height: 30px;
            box-sizing: border-box;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        #info-panel {
            width: 150px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        #next-piece {
            width: 120px;
            height: 120px;
            border: 2px solid #333;
            background-color: #111;
            position: relative;
        }
        #score-display, #level-display {
            font-size: 24px;
            font-weight: bold;
        }
        button {
            padding: 10px;
            font-size: 16px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
        }
        button:hover {
            background-color: #45a049;
        }
    </style>
</head>
<body>
    <h1>Tetris</h1>
    <div id="game-container">
        <div id="game-board"></div>
        <div id="info-panel">
            <div id="next-piece"></div>
            <div id="score-display">Score: 0</div>
            <div id="level-display">Level: 1</div>
            <button id="start-btn">Start Game</button>
            <button id="pause-btn">Pause</button>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Game constants
            const COLS = 10;
            const ROWS = 20;
            const BLOCK_SIZE = 30;
            const SHAPES = [
                [[1, 1, 1, 1]], // I
                [[1, 1], [1, 1]], // O
                [[1, 1, 1], [0, 1, 0]], // T
                [[1, 1, 1], [1, 0, 0]], // L
                [[1, 1, 1], [0, 0, 1]], // J
                [[0, 1, 1], [1, 1, 0]], // S
                [[1, 1, 0], [0, 1, 1]]  // Z
            ];
            const COLORS = [
                '#00FFFF', // I - Cyan
                '#FFFF00', // O - Yellow
                '#AA00FF', // T - Purple
                '#FFA500', // L - Orange
                '#0000FF', // J - Blue
                '#00FF00', // S - Green
                '#FF0000'  // Z - Red
            ];

            // Game variables
            let board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
            let currentPiece = null;
            let nextPiece = null;
            let score = 0;
            let level = 1;
            let gameInterval;
            let isPaused = false;
            let isGameOver = false;
            let dropSpeed = 1000; // Initial speed in ms

            // DOM elements
            const gameBoard = document.getElementById('game-board');
            const nextPieceDisplay = document.getElementById('next-piece');
            const scoreDisplay = document.getElementById('score-display');
            const levelDisplay = document.getElementById('level-display');
            const startBtn = document.getElementById('start-btn');
            const pauseBtn = document.getElementById('pause-btn');

            // Initialize the game
            function init() {
                createBoard();
                startBtn.addEventListener('click', startGame);
                pauseBtn.addEventListener('click', togglePause);
                document.addEventListener('keydown', handleKeyPress);
            }

            // Create the game board grid
            function createBoard() {
                gameBoard.innerHTML = '';
                for (let row = 0; row < ROWS; row++) {
                    for (let col = 0; col < COLS; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'block';
                        cell.id = `${row}-${col}`;
                        cell.style.left = `${col * BLOCK_SIZE}px`;
                        cell.style.top = `${row * BLOCK_SIZE}px`;
                        gameBoard.appendChild(cell);
                    }
                }
            }

            // Start a new game
            function startGame() {
                if (gameInterval) clearInterval(gameInterval);
                board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
                score = 0;
                level = 1;
                dropSpeed = 1000;
                isGameOver = false;
                isPaused = false;
                updateScore();
                updateLevel();
                nextPiece = generatePiece();
                spawnNewPiece();
                gameInterval = setInterval(moveDown, dropSpeed);
            }

            // Generate a random piece
            function generatePiece() {
                const shapeIndex = Math.floor(Math.random() * SHAPES.length);
                const shape = SHAPES[shapeIndex];
                const color = COLORS[shapeIndex];
                
                return {
                    shape,
                    color,
                    x: Math.floor(COLS / 2) - Math.floor(shape[0].length / 2),
                    y: 0
                };
            }

            // Spawn a new piece
            function spawnNewPiece() {
                currentPiece = nextPiece;
                nextPiece = generatePiece();
                drawNextPiece();
                
                if (checkCollision()) {
                    gameOver();
                }
            }

            // Draw the next piece preview
            function drawNextPiece() {
                nextPieceDisplay.innerHTML = '';
                const shape = nextPiece.shape;
                const color = nextPiece.color;
                
                for (let row = 0; row < shape.length; row++) {
                    for (let col = 0; col < shape[row].length; col++) {
                        if (shape[row][col]) {
                            const block = document.createElement('div');
                            block.className = 'block';
                            block.style.backgroundColor = color;
                            block.style.left = `${col * BLOCK_SIZE}px`;
                            block.style.top = `${row * BLOCK_SIZE}px`;
                            nextPieceDisplay.appendChild(block);
                        }
                    }
                }
            }

            // Draw the current piece and board
            function draw() {
                // Clear the board
                for (let row = 0; row < ROWS; row++) {
                    for (let col = 0; col < COLS; col++) {
                        const cell = document.getElementById(`${row}-${col}`);
                        cell.style.backgroundColor = board[row][col] ? board[row][col] : '';
                    }
                }
                
                // Draw the current piece
                const shape = currentPiece.shape;
                for (let row = 0; row < shape.length; row++) {
                    for (let col = 0; col < shape[row].length; col++) {
                        if (shape[row][col]) {
                            const cell = document.getElementById(
                                `${currentPiece.y + row}-${currentPiece.x + col}`
                            );
                            if (cell) {
                                cell.style.backgroundColor = currentPiece.color;
                            }
                        }
                    }
                }
            }

            // Check for collisions
            function checkCollision(offsetX = 0, offsetY = 0) {
                const shape = currentPiece.shape;
                for (let row = 0; row < shape.length; row++) {
                    for (let col = 0; col < shape[row].length; col++) {
                        if (shape[row][col]) {
                            const newX = currentPiece.x + col + offsetX;
                            const newY = currentPiece.y + row + offsetY;
                            
                            if (
                                newX < 0 || 
                                newX >= COLS || 
                                newY >= ROWS ||
                                (newY >= 0 && board[newY][newX])
                            ) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }

            // Lock the piece in place
            function lockPiece() {
                const shape = currentPiece.shape;
                for (let row = 0; row < shape.length; row++) {
                    for (let col = 0; col < shape[row].length; col++) {
                        if (shape[row][col]) {
                            const y = currentPiece.y + row;
                            const x = currentPiece.x + col;
                            if (y >= 0) {
                                board[y][x] = currentPiece.color;
                            }
                        }
                    }
                }
                
                // Check for completed lines
                checkLines();
                spawnNewPiece();
            }

            // Check for completed lines
            function checkLines() {
                let linesCleared = 0;
                
                for (let row = ROWS - 1; row >= 0; row--) {
                    if (board[row].every(cell => cell)) {
                        // Remove the line
                        board.splice(row, 1);
                        // Add new empty line at top
                        board.unshift(Array(COLS).fill(0));
                        linesCleared++;
                        row++; // Check the same row again
                    }
                }
                
                if (linesCleared > 0) {
                    // Update score
                    score += linesCleared * linesCleared * 100 * level;
                    updateScore();
                    
                    // Check for level up (every 10 lines)
                    const newLevel = Math.floor(score / 1000) + 1;
                    if (newLevel > level) {
                        level = newLevel;
                        dropSpeed = Math.max(100, 1000 - (level - 1) * 100);
                        clearInterval(gameInterval);
                        gameInterval = setInterval(moveDown, dropSpeed);
                        updateLevel();
                    }
                }
            }

            // Move piece down
            function moveDown() {
                if (isPaused || isGameOver) return;
                
                if (!checkCollision(0, 1)) {
                    currentPiece.y++;
                    draw();
                } else {
                    lockPiece();
                }
            }

            // Move piece left
            function moveLeft() {
                if (isPaused || isGameOver) return;
                
                if (!checkCollision(-1, 0)) {
                    currentPiece.x--;
                    draw();
                }
            }

            // Move piece right
            function moveRight() {
                if (isPaused || isGameOver) return;
                
                if (!checkCollision(1, 0)) {
                    currentPiece.x++;
                    draw();
                }
            }

            // Rotate piece
            function rotate() {
                if (isPaused || isGameOver) return;
                
                const originalShape = currentPiece.shape;
                // Transpose and reverse rows to rotate 90 degrees
                const rotated = currentPiece.shape[0].map((_, i) => 
                    currentPiece.shape.map(row => row[i]).reverse()
                );
                
                currentPiece.shape = rotated;
                if (checkCollision()) {
                    // Revert if rotation causes collision
                    currentPiece.shape = originalShape;
                } else {
                    draw();
                }
            }

            // Hard drop
            function hardDrop() {
                if (isPaused || isGameOver) return;
                
                while (!checkCollision(0, 1)) {
                    currentPiece.y++;
                }
                draw();
                lockPiece();
            }

            // Handle keyboard input
            function handleKeyPress(e) {
                if (isGameOver) return;
                
                switch (e.key) {
                    case 'ArrowLeft':
                        moveLeft();
                        break;
                    case 'ArrowRight':
                        moveRight();
                        break;
                    case 'ArrowDown':
                        moveDown();
                        break;
                    case 'ArrowUp':
                        rotate();
                        break;
                    case ' ':
                        hardDrop();
                        break;
                    case 'p':
                        togglePause();
                        break;
                }
            }

            // Toggle pause
            function togglePause() {
                isPaused = !isPaused;
                pauseBtn.textContent = isPaused ? 'Resume' : 'Pause';
            }

            // Update score display
            function updateScore() {
                scoreDisplay.textContent = `Score: ${score}`;
            }

            // Update level display
            function updateLevel() {
                levelDisplay.textContent = `Level: ${level}`;
            }

            // Game over
            function gameOver() {
                isGameOver = true;
                clearInterval(gameInterval);
                alert(`Game Over! Your score: ${score}`);
            }

            // Initialize the game
            init();
        });
    </script>
</body>
</html>
